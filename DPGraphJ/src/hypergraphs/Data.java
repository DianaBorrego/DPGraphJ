package hypergraphs;

import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Predicate;
import java.util.stream.Collectors;

import org.jgrapht.graph.DefaultEdge;
import org.jgrapht.graph.SimpleDirectedGraph;

import colors.GraphColors;
import colors.GraphColors.ArrowHead;
import colors.GraphColors.Color;
import colors.GraphColors.Shape;
import graphs.alg.DP.Sp;
import utils.SetMultimap;
import utils.Union;

/**
 * Class that stores in a Map the information of the problems (vertices) 
 * that have been generated so far, together with their associated partial 
 * solution Sp, so as to avoid repeating calculations.
 *
 * It obtains the resulting graph after the generation of the virtual vertices 
 * and edges as the initial problem is solved, and contains methods that allow 
 * the generation of a dot file for its visualization as a graph using the 
 * GraphViz tool.
 *
 * @param <V> type of the vertices
 * @param <E> type of the edges
 * @param <A> type of the alternatives
 */

public class Data<V extends HyperVertex<V, E, A, ?>,E extends HyperEdge<V,E,A,?>,A> {

	private static Object data = null;

	@SuppressWarnings("unchecked")
	public static <V extends HyperVertex<V, E, A, ?>,E extends HyperEdge<V,E,A,?>,A> Data<V, E, A> get() {
		if(data == null) data = new Data<>();
		return (Data<V, E, A>) data;
	}

	private Comparator<Sp<E>> cmp;

	private Data() {
		super();
		this.cmp = Data.type.equals(Data.DpType.Min) ? Comparator.naturalOrder()
				: Comparator.reverseOrder();
	}
	
	/**
	 * Map to store the calculated partial solutions
	 */
	private Map<V,Sp<E>> memory = new HashMap<>();
	
	/**
	 * Map whose keys are the vertices and values are the set of partial solutions associated to them.
	 */
	public SetMultimap<V,Sp<E>> allProblems = SetMultimap.create();

	/**
	 * Type of optimization pursued
	 */
	public static enum DpType{Max, Min}
	public static DpType type = DpType.Min;


	public Sp<E> get(V v){
		return memory.get(v);
	}
	public Set<Sp<E>> getAll(V v){
		return allProblems.get(v);
	}
	public void put(V v, Sp<E> s){
		memory.put(v, s);
	}
	public void putAll(V v, Sp<E> s){
		allProblems.put(v,s);
	}
	public Boolean contains(V v){
		return memory.containsKey(v);
	}
	public Set<V> vertices(){
		return memory.keySet();
	}
	public Comparator<Sp<E>> order(){
		return cmp;
	}
	
	/**
	 * 
	 * @return SimpleDirectedGraph where the vertices are the 
	 * virtual vertices and edges generated in the process of 
	 * solving the initial problem, and the edges are the relations 
	 * between them, forming an AND/OR graph.
	 */

	public SimpleDirectedGraph<Union<V, E>, DefaultEdge> graph() {

		SimpleDirectedGraph<Union<V, E>, DefaultEdge> graph =
				new SimpleDirectedGraph<>(null, ()->new DefaultEdge(),true);

		Set<V> vertices = this.vertices();
		for (V v : vertices) {
			graph.addVertex(Union.ofA(v));
		}
		for (V v : vertices) {
			Set<Sp<E>> alls = this.getAll(v);
			if (alls != null) {
				for (Sp<E> s : alls) {
					if (s != null) {
						E e = s.edge();
						if (e != null) {
							Union<V,E> source = Union.ofA(e.source());
							List<Union<V,E>> targets = e.targets().stream().map(x -> Union.<V,E>ofA(x)).toList();
							Union<V,E> ve = Union.ofB(e);
							graph.addVertex(ve);
							graph.addEdge(source, ve);
							for (Union<V, E> t : targets) {
								graph.addEdge(ve, t);
							}
						}
					}
				}
			}
		}
		return graph;
	}

	public static <V,E> String stv(Union<V,E> un) {
		if(un.isA()) return un.a().toString();
		else return un.b().toString().substring(0, 1).toUpperCase();
	}

	public static <V,E> String ste(Union<V,E> un) {
		if(un.isA()) return un.a().toString();
		else return un.b().toString().substring(0, 1).toUpperCase();
	}
	
	/**
	 * Generates the dot file, named "file", which contains the resulting 
	 * hypergraph after solving the problem, so that it can be viewed by the user.
	 * 
	 * @param g SimpleDirectedGraph, which can be previously generated by invoking to the method graph()
	 * @param file name of the dot file
	 * @param initial initial vertex
	 */

	public static <V extends HyperVertex<V, E, A, ?>, E extends HyperEdge<V,E,A,?>, A>
		void toDotHypergraph(SimpleDirectedGraph<Union<V,E>, DefaultEdge> g, String file, V initial) {

		Set<Union<V,E>> vt = initial.graphTree().vertices().stream()
				.<Union<V,E>>map(x -> Union.ofA(x)).collect(Collectors.toSet());

		Set<Union<V,E>> et = initial.graphTree().hyperEdges().stream()
				.<Union<V,E>>map(v -> Union.ofB(v))
				.collect(Collectors.toSet());

		Predicate<DefaultEdge> pd = e->et.contains(g.getEdgeSource(e)) || et.contains(g.getEdgeTarget(e));

		GraphColors.toDot(g, file,
				x -> stv(x),
				x -> g.getEdgeSource(x).isA() ? g.getEdgeTarget(x).b().toString().substring(0, 1).toUpperCase() : "",
				x -> GraphColors.all(GraphColors.shapeIf(Shape.point, x.isB()),
						GraphColors.colorIf(Color.red, vt.contains(x))),
				e -> GraphColors.all(GraphColors.arrowHead(ArrowHead.none),
						GraphColors.colorIf(Color.red, pd.test(e))));
	}
	
	/**
	 * Generates the dot file, named "file", which contains the resulting 
	 * AND/OR graph after solving the problem, so that it can be viewed by the user.
	 * 
	 * @param g SimpleDirectedGraph, which can be previously generated by invoking to the method graph()
	 * @param file name of the dot file
	 * @param initial initial vertex
	 */

	public static <V extends HyperVertex<V, E, A, ?>, E extends HyperEdge<V,E,A,?>,A>
		void toDotAndOr(SimpleDirectedGraph<Union<V,E>, DefaultEdge> g,
			String file, V initial) {

		Set<Union<V,E>> vt = initial.graphTree().vertices().stream()
				.<Union<V,E>>map(x -> Union.ofA(x)).collect(Collectors.toSet());

		Set<Union<V,E>> et = initial.graphTree().hyperEdges().stream()
				.<Union<V,E>>map(v -> Union.ofB(v))
				.collect(Collectors.toSet());

		Predicate<DefaultEdge> pd = e->et.contains(g.getEdgeSource(e)) || et.contains(g.getEdgeTarget(e));

		GraphColors.toDot(g, file,
				x -> stv(x),
				x -> "",
				x -> GraphColors.all(GraphColors.shapeIf(Shape.box, x.isA()),
						GraphColors.colorIf(Color.red, vt.contains(x) || et.contains(x))),
				e -> GraphColors.all(GraphColors.arrowHead(ArrowHead.none),
						GraphColors.colorIf(Color.red, pd.test(e))));
	}


}
